#include "VoxelConverter.h"

#include "console.h"
#include "Matter.h"
#include "MatterNode.h"
#include "VoxelDecomposer.h"
#include "VoxelField.h"
#include "VertexShell.h"
#include <string.h>

RegularCellData::RegularCellData(GLuint geometryCounts, std::initializer_list<unsigned int> brace)
{
    init(geometryCounts, brace.begin());
}

void RegularCellData::init(GLuint geometryCounts, const GLuint* vertexIndex)
{
    mGeometryCounts = geometryCounts;
    for(int i = 0; i < 15; i++)
    {
        mVertexIndex[i] = vertexIndex[i];
    }
}

RegularCellData::~RegularCellData()
{

}

GLuint RegularCellData::getVertexCount()
{
    return mGeometryCounts >> 4;
}

GLuint RegularCellData::getTriangleCount()
{
    return mGeometryCounts & 0x0F;
}

const GLuint VoxelConverter::regularCellClass[256] =
{
    0x00, 0x01, 0x01, 0x03, 0x01, 0x03, 0x02, 0x04, 0x01, 0x02, 0x03, 0x04, 0x03, 0x04, 0x04, 0x03,
    0x01, 0x03, 0x02, 0x04, 0x02, 0x04, 0x06, 0x0C, 0x02, 0x05, 0x05, 0x0B, 0x05, 0x0A, 0x07, 0x04,
    0x01, 0x02, 0x03, 0x04, 0x02, 0x05, 0x05, 0x0A, 0x02, 0x06, 0x04, 0x0C, 0x05, 0x07, 0x0B, 0x04,
    0x03, 0x04, 0x04, 0x03, 0x05, 0x0B, 0x07, 0x04, 0x05, 0x07, 0x0A, 0x04, 0x08, 0x0E, 0x0E, 0x03,
    0x01, 0x02, 0x02, 0x05, 0x03, 0x04, 0x05, 0x0B, 0x02, 0x06, 0x05, 0x07, 0x04, 0x0C, 0x0A, 0x04,
    0x03, 0x04, 0x05, 0x0A, 0x04, 0x03, 0x07, 0x04, 0x05, 0x07, 0x08, 0x0E, 0x0B, 0x04, 0x0E, 0x03,
    0x02, 0x06, 0x05, 0x07, 0x05, 0x07, 0x08, 0x0E, 0x06, 0x09, 0x07, 0x0F, 0x07, 0x0F, 0x0E, 0x0D,
    0x04, 0x0C, 0x0B, 0x04, 0x0A, 0x04, 0x0E, 0x03, 0x07, 0x0F, 0x0E, 0x0D, 0x0E, 0x0D, 0x02, 0x01,
    0x01, 0x02, 0x02, 0x05, 0x02, 0x05, 0x06, 0x07, 0x03, 0x05, 0x04, 0x0A, 0x04, 0x0B, 0x0C, 0x04,
    0x02, 0x05, 0x06, 0x07, 0x06, 0x07, 0x09, 0x0F, 0x05, 0x08, 0x07, 0x0E, 0x07, 0x0E, 0x0F, 0x0D,
    0x03, 0x05, 0x04, 0x0B, 0x05, 0x08, 0x07, 0x0E, 0x04, 0x07, 0x03, 0x04, 0x0A, 0x0E, 0x04, 0x03,
    0x04, 0x0A, 0x0C, 0x04, 0x07, 0x0E, 0x0F, 0x0D, 0x0B, 0x0E, 0x04, 0x03, 0x0E, 0x02, 0x0D, 0x01,
    0x03, 0x05, 0x05, 0x08, 0x04, 0x0A, 0x07, 0x0E, 0x04, 0x07, 0x0B, 0x0E, 0x03, 0x04, 0x04, 0x03,
    0x04, 0x0B, 0x07, 0x0E, 0x0C, 0x04, 0x0F, 0x0D, 0x0A, 0x0E, 0x0E, 0x02, 0x04, 0x03, 0x0D, 0x01,
    0x04, 0x07, 0x0A, 0x0E, 0x0B, 0x0E, 0x0E, 0x02, 0x0C, 0x0F, 0x04, 0x0D, 0x04, 0x0D, 0x03, 0x01,
    0x03, 0x04, 0x04, 0x03, 0x04, 0x03, 0x0D, 0x01, 0x04, 0x0D, 0x03, 0x01, 0x03, 0x01, 0x01, 0x00
};

RegularCellData VoxelConverter::regularCellData[16] =
{
    RegularCellData(0x00, {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}),
    RegularCellData(0x31, {0,1,2,0,0,0,0,0,0,0,0,0,0,0,0}),
    RegularCellData(0x62, {0,1,2,3,4,5,0,0,0,0,0,0,0,0,0}),
    RegularCellData(0x42, {0,1,2,0,2,3,0,0,0,0,0,0,0,0,0}),
    RegularCellData(0x53, {0,1,4,1,3,4,1,2,3,0,0,0,0,0,0}),
    RegularCellData(0x73, {0,1,2,0,2,3,4,5,6,0,0,0,0,0,0}),
    RegularCellData(0x93, {0,1,2,3,4,5,6,7,8,0,0,0,0,0,0}),
    RegularCellData(0x84, {0,1,4,1,3,4,1,2,3,5,6,7,0,0,0}),
    RegularCellData(0x84, {0,1,2,0,2,3,4,5,6,4,6,7,0,0,0}),
    RegularCellData(0xC4, {0,1,2,3,4,5,6,7,8,9,10,11,0,0,0}),
    RegularCellData(0x64, {0,4,5,0,1,4,1,3,4,1,2,3,0,0,0}),
    RegularCellData(0x64, {0,5,4,0,4,1,1,4,3,1,3,2,0,0,0}),
    RegularCellData(0x64, {0,4,5,0,3,4,0,1,3,1,2,3,0,0,0}),
    RegularCellData(0x64, {0,1,2,0,2,3,0,3,4,0,4,5,0,0,0}),
    RegularCellData(0x75, {0,1,2,0,2,3,0,3,4,0,4,5,0,5,6}),
    RegularCellData(0x95, {0,4,5,0,3,4,0,1,3,1,2,3,6,7,8})
};

const GLuint VoxelConverter::regularVertexData[3072] =
{
        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x6201, 0x5102, 0x3304, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x6201, 0x2315, 0x4113, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x5102, 0x3304, 0x2315, 0x4113, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x5102, 0x4223, 0x1326, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x3304, 0x6201, 0x4223, 0x1326, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x6201, 0x2315, 0x4113, 0x5102, 0x4223, 0x1326, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x4223, 0x1326, 0x3304, 0x2315, 0x4113, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x4113, 0x8337, 0x4223, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x6201, 0x5102, 0x3304, 0x4223, 0x4113, 0x8337, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x6201, 0x2315, 0x8337, 0x4223, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x5102, 0x3304, 0x2315, 0x8337, 0x4223, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x5102, 0x4113, 0x8337, 0x1326, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x4113, 0x8337, 0x1326, 0x3304, 0x6201, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x6201, 0x2315, 0x8337, 0x1326, 0x5102, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x3304, 0x2315, 0x8337, 0x1326, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x3304, 0x1146, 0x2245, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x6201, 0x5102, 0x1146, 0x2245, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x6201, 0x2315, 0x4113, 0x3304, 0x1146, 0x2245, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x2315, 0x4113, 0x5102, 0x1146, 0x2245, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x5102, 0x4223, 0x1326, 0x3304, 0x1146, 0x2245, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x1146, 0x2245, 0x6201, 0x4223, 0x1326, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x3304, 0x1146, 0x2245, 0x6201, 0x2315, 0x4113, 0x5102, 0x4223, 0x1326, 0x0000, 0x0000, 0x0000,
        0x4223, 0x1326, 0x1146, 0x2245, 0x2315, 0x4113, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x4223, 0x4113, 0x8337, 0x3304, 0x1146, 0x2245, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x6201, 0x5102, 0x1146, 0x2245, 0x4223, 0x4113, 0x8337, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x4223, 0x6201, 0x2315, 0x8337, 0x3304, 0x1146, 0x2245, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x4223, 0x8337, 0x2315, 0x2245, 0x1146, 0x5102, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x5102, 0x4113, 0x8337, 0x1326, 0x3304, 0x1146, 0x2245, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x4113, 0x8337, 0x1326, 0x1146, 0x2245, 0x6201, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x6201, 0x2315, 0x8337, 0x1326, 0x5102, 0x3304, 0x1146, 0x2245, 0x0000, 0x0000, 0x0000, 0x0000,
        0x2245, 0x2315, 0x8337, 0x1326, 0x1146, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x2315, 0x2245, 0x8157, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x6201, 0x5102, 0x3304, 0x2315, 0x2245, 0x8157, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x4113, 0x6201, 0x2245, 0x8157, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x2245, 0x8157, 0x4113, 0x5102, 0x3304, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x5102, 0x4223, 0x1326, 0x2315, 0x2245, 0x8157, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x6201, 0x4223, 0x1326, 0x3304, 0x2315, 0x2245, 0x8157, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x6201, 0x2245, 0x8157, 0x4113, 0x5102, 0x4223, 0x1326, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x4223, 0x1326, 0x3304, 0x2245, 0x8157, 0x4113, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x4223, 0x4113, 0x8337, 0x2315, 0x2245, 0x8157, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x6201, 0x5102, 0x3304, 0x4223, 0x4113, 0x8337, 0x2315, 0x2245, 0x8157, 0x0000, 0x0000, 0x0000,
        0x8337, 0x4223, 0x6201, 0x2245, 0x8157, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x5102, 0x3304, 0x2245, 0x8157, 0x8337, 0x4223, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x5102, 0x4113, 0x8337, 0x1326, 0x2315, 0x2245, 0x8157, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x4113, 0x8337, 0x1326, 0x3304, 0x6201, 0x2315, 0x2245, 0x8157, 0x0000, 0x0000, 0x0000, 0x0000,
        0x5102, 0x1326, 0x8337, 0x8157, 0x2245, 0x6201, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x8157, 0x8337, 0x1326, 0x3304, 0x2245, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x2315, 0x3304, 0x1146, 0x8157, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x6201, 0x5102, 0x1146, 0x8157, 0x2315, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x3304, 0x1146, 0x8157, 0x4113, 0x6201, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x4113, 0x5102, 0x1146, 0x8157, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x2315, 0x3304, 0x1146, 0x8157, 0x5102, 0x4223, 0x1326, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x1326, 0x4223, 0x6201, 0x2315, 0x8157, 0x1146, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x3304, 0x1146, 0x8157, 0x4113, 0x6201, 0x5102, 0x4223, 0x1326, 0x0000, 0x0000, 0x0000, 0x0000,
        0x1326, 0x1146, 0x8157, 0x4113, 0x4223, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x2315, 0x3304, 0x1146, 0x8157, 0x4223, 0x4113, 0x8337, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x6201, 0x5102, 0x1146, 0x8157, 0x2315, 0x4223, 0x4113, 0x8337, 0x0000, 0x0000, 0x0000, 0x0000,
        0x3304, 0x1146, 0x8157, 0x8337, 0x4223, 0x6201, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x4223, 0x5102, 0x1146, 0x8157, 0x8337, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x2315, 0x3304, 0x1146, 0x8157, 0x5102, 0x4113, 0x8337, 0x1326, 0x0000, 0x0000, 0x0000, 0x0000,
        0x6201, 0x4113, 0x8337, 0x1326, 0x1146, 0x8157, 0x2315, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x6201, 0x3304, 0x1146, 0x8157, 0x8337, 0x1326, 0x5102, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x1326, 0x1146, 0x8157, 0x8337, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x1326, 0x8267, 0x1146, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x6201, 0x5102, 0x3304, 0x1326, 0x8267, 0x1146, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x6201, 0x2315, 0x4113, 0x1326, 0x8267, 0x1146, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x5102, 0x3304, 0x2315, 0x4113, 0x1326, 0x8267, 0x1146, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x5102, 0x4223, 0x8267, 0x1146, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x3304, 0x6201, 0x4223, 0x8267, 0x1146, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x5102, 0x4223, 0x8267, 0x1146, 0x6201, 0x2315, 0x4113, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x1146, 0x8267, 0x4223, 0x4113, 0x2315, 0x3304, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x4113, 0x8337, 0x4223, 0x1326, 0x8267, 0x1146, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x6201, 0x5102, 0x3304, 0x4223, 0x4113, 0x8337, 0x1326, 0x8267, 0x1146, 0x0000, 0x0000, 0x0000,
        0x6201, 0x2315, 0x8337, 0x4223, 0x1326, 0x8267, 0x1146, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x5102, 0x3304, 0x2315, 0x8337, 0x4223, 0x1326, 0x8267, 0x1146, 0x0000, 0x0000, 0x0000, 0x0000,
        0x8267, 0x1146, 0x5102, 0x4113, 0x8337, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x6201, 0x4113, 0x8337, 0x8267, 0x1146, 0x3304, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x6201, 0x2315, 0x8337, 0x8267, 0x1146, 0x5102, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x1146, 0x3304, 0x2315, 0x8337, 0x8267, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x3304, 0x1326, 0x8267, 0x2245, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x1326, 0x8267, 0x2245, 0x6201, 0x5102, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x3304, 0x1326, 0x8267, 0x2245, 0x6201, 0x2315, 0x4113, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x1326, 0x8267, 0x2245, 0x2315, 0x4113, 0x5102, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x5102, 0x4223, 0x8267, 0x2245, 0x3304, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x6201, 0x4223, 0x8267, 0x2245, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x5102, 0x4223, 0x8267, 0x2245, 0x3304, 0x6201, 0x2315, 0x4113, 0x0000, 0x0000, 0x0000, 0x0000,
        0x4113, 0x4223, 0x8267, 0x2245, 0x2315, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x3304, 0x1326, 0x8267, 0x2245, 0x4223, 0x4113, 0x8337, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x1326, 0x8267, 0x2245, 0x6201, 0x5102, 0x4223, 0x4113, 0x8337, 0x0000, 0x0000, 0x0000, 0x0000,
        0x3304, 0x1326, 0x8267, 0x2245, 0x4223, 0x6201, 0x2315, 0x8337, 0x0000, 0x0000, 0x0000, 0x0000,
        0x5102, 0x1326, 0x8267, 0x2245, 0x2315, 0x8337, 0x4223, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x3304, 0x2245, 0x8267, 0x8337, 0x4113, 0x5102, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x8337, 0x8267, 0x2245, 0x6201, 0x4113, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x5102, 0x6201, 0x2315, 0x8337, 0x8267, 0x2245, 0x3304, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x2315, 0x8337, 0x8267, 0x2245, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x2315, 0x2245, 0x8157, 0x1326, 0x8267, 0x1146, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x6201, 0x5102, 0x3304, 0x2315, 0x2245, 0x8157, 0x1326, 0x8267, 0x1146, 0x0000, 0x0000, 0x0000,
        0x6201, 0x2245, 0x8157, 0x4113, 0x1326, 0x8267, 0x1146, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x2245, 0x8157, 0x4113, 0x5102, 0x3304, 0x1326, 0x8267, 0x1146, 0x0000, 0x0000, 0x0000, 0x0000,
        0x4223, 0x8267, 0x1146, 0x5102, 0x2315, 0x2245, 0x8157, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x3304, 0x6201, 0x4223, 0x8267, 0x1146, 0x2315, 0x2245, 0x8157, 0x0000, 0x0000, 0x0000, 0x0000,
        0x4223, 0x8267, 0x1146, 0x5102, 0x6201, 0x2245, 0x8157, 0x4113, 0x0000, 0x0000, 0x0000, 0x0000,
        0x3304, 0x2245, 0x8157, 0x4113, 0x4223, 0x8267, 0x1146, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x4223, 0x4113, 0x8337, 0x2315, 0x2245, 0x8157, 0x1326, 0x8267, 0x1146, 0x0000, 0x0000, 0x0000,
        0x6201, 0x5102, 0x3304, 0x4223, 0x4113, 0x8337, 0x2315, 0x2245, 0x8157, 0x1326, 0x8267, 0x1146,
        0x8337, 0x4223, 0x6201, 0x2245, 0x8157, 0x1326, 0x8267, 0x1146, 0x0000, 0x0000, 0x0000, 0x0000,
        0x4223, 0x5102, 0x3304, 0x2245, 0x8157, 0x8337, 0x1326, 0x8267, 0x1146, 0x0000, 0x0000, 0x0000,
        0x8267, 0x1146, 0x5102, 0x4113, 0x8337, 0x2315, 0x2245, 0x8157, 0x0000, 0x0000, 0x0000, 0x0000,
        0x6201, 0x4113, 0x8337, 0x8267, 0x1146, 0x3304, 0x2315, 0x2245, 0x8157, 0x0000, 0x0000, 0x0000,
        0x8337, 0x8267, 0x1146, 0x5102, 0x6201, 0x2245, 0x8157, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x3304, 0x2245, 0x8157, 0x8337, 0x8267, 0x1146, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x8157, 0x2315, 0x3304, 0x1326, 0x8267, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x8267, 0x8157, 0x2315, 0x6201, 0x5102, 0x1326, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x8267, 0x1326, 0x3304, 0x6201, 0x4113, 0x8157, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x8267, 0x8157, 0x4113, 0x5102, 0x1326, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x5102, 0x4223, 0x8267, 0x8157, 0x2315, 0x3304, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x2315, 0x6201, 0x4223, 0x8267, 0x8157, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x3304, 0x5102, 0x4223, 0x8267, 0x8157, 0x4113, 0x6201, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x4113, 0x4223, 0x8267, 0x8157, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x8157, 0x2315, 0x3304, 0x1326, 0x8267, 0x4223, 0x4113, 0x8337, 0x0000, 0x0000, 0x0000, 0x0000,
        0x8157, 0x2315, 0x6201, 0x5102, 0x1326, 0x8267, 0x4223, 0x4113, 0x8337, 0x0000, 0x0000, 0x0000,
        0x8157, 0x8337, 0x4223, 0x6201, 0x3304, 0x1326, 0x8267, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x5102, 0x1326, 0x8267, 0x8157, 0x8337, 0x4223, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x8267, 0x8157, 0x2315, 0x3304, 0x5102, 0x4113, 0x8337, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x6201, 0x4113, 0x8337, 0x8267, 0x8157, 0x2315, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x6201, 0x3304, 0x5102, 0x8337, 0x8267, 0x8157, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x8337, 0x8267, 0x8157, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x8337, 0x8157, 0x8267, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x6201, 0x5102, 0x3304, 0x8337, 0x8157, 0x8267, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x6201, 0x2315, 0x4113, 0x8337, 0x8157, 0x8267, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x5102, 0x3304, 0x2315, 0x4113, 0x8337, 0x8157, 0x8267, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x5102, 0x4223, 0x1326, 0x8337, 0x8157, 0x8267, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x6201, 0x4223, 0x1326, 0x3304, 0x8337, 0x8157, 0x8267, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x6201, 0x2315, 0x4113, 0x5102, 0x4223, 0x1326, 0x8337, 0x8157, 0x8267, 0x0000, 0x0000, 0x0000,
        0x4223, 0x1326, 0x3304, 0x2315, 0x4113, 0x8337, 0x8157, 0x8267, 0x0000, 0x0000, 0x0000, 0x0000,
        0x4113, 0x8157, 0x8267, 0x4223, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x4223, 0x4113, 0x8157, 0x8267, 0x6201, 0x5102, 0x3304, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x8157, 0x8267, 0x4223, 0x6201, 0x2315, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x3304, 0x2315, 0x8157, 0x8267, 0x4223, 0x5102, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x1326, 0x5102, 0x4113, 0x8157, 0x8267, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x8157, 0x4113, 0x6201, 0x3304, 0x1326, 0x8267, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x1326, 0x5102, 0x6201, 0x2315, 0x8157, 0x8267, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x8267, 0x1326, 0x3304, 0x2315, 0x8157, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x3304, 0x1146, 0x2245, 0x8337, 0x8157, 0x8267, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x6201, 0x5102, 0x1146, 0x2245, 0x8337, 0x8157, 0x8267, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x6201, 0x2315, 0x4113, 0x3304, 0x1146, 0x2245, 0x8337, 0x8157, 0x8267, 0x0000, 0x0000, 0x0000,
        0x2315, 0x4113, 0x5102, 0x1146, 0x2245, 0x8337, 0x8157, 0x8267, 0x0000, 0x0000, 0x0000, 0x0000,
        0x5102, 0x4223, 0x1326, 0x3304, 0x1146, 0x2245, 0x8337, 0x8157, 0x8267, 0x0000, 0x0000, 0x0000,
        0x1146, 0x2245, 0x6201, 0x4223, 0x1326, 0x8337, 0x8157, 0x8267, 0x0000, 0x0000, 0x0000, 0x0000,
        0x6201, 0x2315, 0x4113, 0x5102, 0x4223, 0x1326, 0x3304, 0x1146, 0x2245, 0x8337, 0x8157, 0x8267,
        0x4113, 0x4223, 0x1326, 0x1146, 0x2245, 0x2315, 0x8337, 0x8157, 0x8267, 0x0000, 0x0000, 0x0000,
        0x4223, 0x4113, 0x8157, 0x8267, 0x3304, 0x1146, 0x2245, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x6201, 0x5102, 0x1146, 0x2245, 0x4223, 0x4113, 0x8157, 0x8267, 0x0000, 0x0000, 0x0000, 0x0000,
        0x8157, 0x8267, 0x4223, 0x6201, 0x2315, 0x3304, 0x1146, 0x2245, 0x0000, 0x0000, 0x0000, 0x0000,
        0x2315, 0x8157, 0x8267, 0x4223, 0x5102, 0x1146, 0x2245, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x1326, 0x5102, 0x4113, 0x8157, 0x8267, 0x3304, 0x1146, 0x2245, 0x0000, 0x0000, 0x0000, 0x0000,
        0x1326, 0x1146, 0x2245, 0x6201, 0x4113, 0x8157, 0x8267, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x5102, 0x6201, 0x2315, 0x8157, 0x8267, 0x1326, 0x3304, 0x1146, 0x2245, 0x0000, 0x0000, 0x0000,
        0x1326, 0x1146, 0x2245, 0x2315, 0x8157, 0x8267, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x2315, 0x2245, 0x8267, 0x8337, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x2315, 0x2245, 0x8267, 0x8337, 0x6201, 0x5102, 0x3304, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x4113, 0x6201, 0x2245, 0x8267, 0x8337, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x5102, 0x4113, 0x8337, 0x8267, 0x2245, 0x3304, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x2315, 0x2245, 0x8267, 0x8337, 0x5102, 0x4223, 0x1326, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x6201, 0x4223, 0x1326, 0x3304, 0x8337, 0x2315, 0x2245, 0x8267, 0x0000, 0x0000, 0x0000, 0x0000,
        0x4113, 0x6201, 0x2245, 0x8267, 0x8337, 0x5102, 0x4223, 0x1326, 0x0000, 0x0000, 0x0000, 0x0000,
        0x4113, 0x4223, 0x1326, 0x3304, 0x2245, 0x8267, 0x8337, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x2315, 0x2245, 0x8267, 0x4223, 0x4113, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x2315, 0x2245, 0x8267, 0x4223, 0x4113, 0x6201, 0x5102, 0x3304, 0x0000, 0x0000, 0x0000, 0x0000,
        0x6201, 0x2245, 0x8267, 0x4223, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x3304, 0x2245, 0x8267, 0x4223, 0x5102, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x5102, 0x4113, 0x2315, 0x2245, 0x8267, 0x1326, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x4113, 0x2315, 0x2245, 0x8267, 0x1326, 0x3304, 0x6201, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x5102, 0x6201, 0x2245, 0x8267, 0x1326, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x3304, 0x2245, 0x8267, 0x1326, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x8267, 0x8337, 0x2315, 0x3304, 0x1146, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x5102, 0x1146, 0x8267, 0x8337, 0x2315, 0x6201, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x3304, 0x1146, 0x8267, 0x8337, 0x4113, 0x6201, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x8337, 0x4113, 0x5102, 0x1146, 0x8267, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x8267, 0x8337, 0x2315, 0x3304, 0x1146, 0x5102, 0x4223, 0x1326, 0x0000, 0x0000, 0x0000, 0x0000,
        0x1146, 0x8267, 0x8337, 0x2315, 0x6201, 0x4223, 0x1326, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x8267, 0x8337, 0x4113, 0x6201, 0x3304, 0x1146, 0x5102, 0x4223, 0x1326, 0x0000, 0x0000, 0x0000,
        0x4113, 0x4223, 0x1326, 0x1146, 0x8267, 0x8337, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x3304, 0x2315, 0x4113, 0x4223, 0x8267, 0x1146, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x2315, 0x6201, 0x5102, 0x1146, 0x8267, 0x4223, 0x4113, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x1146, 0x8267, 0x4223, 0x6201, 0x3304, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x5102, 0x1146, 0x8267, 0x4223, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x8267, 0x1326, 0x5102, 0x4113, 0x2315, 0x3304, 0x1146, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x6201, 0x4113, 0x2315, 0x1326, 0x1146, 0x8267, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x6201, 0x3304, 0x1146, 0x8267, 0x1326, 0x5102, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x1326, 0x1146, 0x8267, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x1326, 0x8337, 0x8157, 0x1146, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x8337, 0x8157, 0x1146, 0x1326, 0x6201, 0x5102, 0x3304, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x8337, 0x8157, 0x1146, 0x1326, 0x6201, 0x2315, 0x4113, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x4113, 0x5102, 0x3304, 0x2315, 0x1326, 0x8337, 0x8157, 0x1146, 0x0000, 0x0000, 0x0000, 0x0000,
        0x8337, 0x8157, 0x1146, 0x5102, 0x4223, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x6201, 0x4223, 0x8337, 0x8157, 0x1146, 0x3304, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x8337, 0x8157, 0x1146, 0x5102, 0x4223, 0x6201, 0x2315, 0x4113, 0x0000, 0x0000, 0x0000, 0x0000,
        0x4223, 0x8337, 0x8157, 0x1146, 0x3304, 0x2315, 0x4113, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x4223, 0x4113, 0x8157, 0x1146, 0x1326, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x4223, 0x4113, 0x8157, 0x1146, 0x1326, 0x6201, 0x5102, 0x3304, 0x0000, 0x0000, 0x0000, 0x0000,
        0x1146, 0x8157, 0x2315, 0x6201, 0x4223, 0x1326, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x4223, 0x5102, 0x3304, 0x2315, 0x8157, 0x1146, 0x1326, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x4113, 0x8157, 0x1146, 0x5102, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x6201, 0x4113, 0x8157, 0x1146, 0x3304, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x2315, 0x8157, 0x1146, 0x5102, 0x6201, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x2315, 0x8157, 0x1146, 0x3304, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x2245, 0x3304, 0x1326, 0x8337, 0x8157, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x6201, 0x2245, 0x8157, 0x8337, 0x1326, 0x5102, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x2245, 0x3304, 0x1326, 0x8337, 0x8157, 0x6201, 0x2315, 0x4113, 0x0000, 0x0000, 0x0000, 0x0000,
        0x2245, 0x2315, 0x4113, 0x5102, 0x1326, 0x8337, 0x8157, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x4223, 0x8337, 0x8157, 0x2245, 0x3304, 0x5102, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x8157, 0x2245, 0x6201, 0x4223, 0x8337, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x2245, 0x3304, 0x5102, 0x4223, 0x8337, 0x8157, 0x4113, 0x6201, 0x2315, 0x0000, 0x0000, 0x0000,
        0x4223, 0x8337, 0x8157, 0x2245, 0x2315, 0x4113, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x4113, 0x8157, 0x2245, 0x3304, 0x1326, 0x4223, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x1326, 0x4223, 0x4113, 0x8157, 0x2245, 0x6201, 0x5102, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x8157, 0x2245, 0x3304, 0x1326, 0x4223, 0x6201, 0x2315, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x5102, 0x1326, 0x4223, 0x2315, 0x8157, 0x2245, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x3304, 0x5102, 0x4113, 0x8157, 0x2245, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x4113, 0x8157, 0x2245, 0x6201, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x5102, 0x6201, 0x2315, 0x8157, 0x2245, 0x3304, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x2315, 0x8157, 0x2245, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x1146, 0x1326, 0x8337, 0x2315, 0x2245, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x1146, 0x1326, 0x8337, 0x2315, 0x2245, 0x6201, 0x5102, 0x3304, 0x0000, 0x0000, 0x0000, 0x0000,
        0x6201, 0x2245, 0x1146, 0x1326, 0x8337, 0x4113, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x2245, 0x1146, 0x1326, 0x8337, 0x4113, 0x5102, 0x3304, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x5102, 0x1146, 0x2245, 0x2315, 0x8337, 0x4223, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x1146, 0x3304, 0x6201, 0x4223, 0x8337, 0x2315, 0x2245, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x8337, 0x4113, 0x6201, 0x2245, 0x1146, 0x5102, 0x4223, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x4223, 0x8337, 0x4113, 0x3304, 0x2245, 0x1146, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x4113, 0x2315, 0x2245, 0x1146, 0x1326, 0x4223, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x1146, 0x1326, 0x4223, 0x4113, 0x2315, 0x2245, 0x6201, 0x5102, 0x3304, 0x0000, 0x0000, 0x0000,
        0x1326, 0x4223, 0x6201, 0x2245, 0x1146, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x4223, 0x5102, 0x3304, 0x2245, 0x1146, 0x1326, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x2245, 0x1146, 0x5102, 0x4113, 0x2315, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x4113, 0x2315, 0x2245, 0x1146, 0x3304, 0x6201, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x6201, 0x2245, 0x1146, 0x5102, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x3304, 0x2245, 0x1146, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x3304, 0x1326, 0x8337, 0x2315, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x5102, 0x1326, 0x8337, 0x2315, 0x6201, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x6201, 0x3304, 0x1326, 0x8337, 0x4113, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x5102, 0x1326, 0x8337, 0x4113, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x4223, 0x8337, 0x2315, 0x3304, 0x5102, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x6201, 0x4223, 0x8337, 0x2315, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x3304, 0x5102, 0x4223, 0x8337, 0x4113, 0x6201, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x4113, 0x4223, 0x8337, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x4113, 0x2315, 0x3304, 0x1326, 0x4223, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x1326, 0x4223, 0x4113, 0x2315, 0x6201, 0x5102, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x3304, 0x1326, 0x4223, 0x6201, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x5102, 0x1326, 0x4223, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x5102, 0x4113, 0x2315, 0x3304, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x6201, 0x4113, 0x2315, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x6201, 0x3304, 0x5102, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
        0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
};

VoxelConverter::VoxelConverter(App* app)
{
    mApp = app;
    mUseCPU = false;
    mVoxelSpacing = 1.0f;
    mXOffset = 0.0f;
    mYOffset = 0.0f;
    mZOffset = 0.0f;
}

VoxelConverter::VoxelConverter(App* app_one, GLfloat voxelSpacing) : VoxelConverter(app_one)
{
    mVoxelSpacing = voxelSpacing;
}

VoxelConverter::~VoxelConverter()
{
    //dtor
}

GLboolean VoxelConverter::initGPU(const char* lst_tri_vert, const char* lst_tri_geom,
                        const char* gen_vert_vert, const char* gen_vert_geom)
{
    //Create a texture
    glGenTextures(1, &mVolumeTexture);

    GLuint initialVerts[29791];

    //Populate the initial vertex buffer
    for(unsigned int z = 0; z < 31; z++)
    {
        for(unsigned int y = 0; y < 31; y++)
        {
            for(unsigned int x = 0; x < 31; x++)
            {
                GLuint x_y_z = 0;
                x_y_z = x_y_z | (x << 25);
                x_y_z = x_y_z | (y << 20);
                x_y_z = x_y_z | (z << 15);
                initialVerts[x+(y*31)+(z*961)] = x_y_z;
            }
        }
    }

    glGenBuffers(1, &mInitialDataBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, mInitialDataBuffer);
    glBufferData(GL_ARRAY_BUFFER, sizeof(initialVerts), initialVerts, GL_DYNAMIC_DRAW);
    glBindBuffer(GL_ARRAY_BUFFER, 0);

    //Create transform feedback object.
    glGenTransformFeedbacks(1, mTransformFeedback);
    glBindTransformFeedback(GL_TRANSFORM_FEEDBACK, 0);

    //Create triangle buffer (initially blank)
    glGenBuffers(1, &mTriangleBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, mTriangleBuffer);
    glBufferData(GL_ARRAY_BUFFER, sizeof(initialVerts)*5, 0, GL_DYNAMIC_DRAW);
    glBindBuffer(GL_ARRAY_BUFFER, 0);

    //Create vertex buffer (initially blank)
    glGenBuffers(1, &mVertexBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, mVertexBuffer);
    glBufferData(GL_ARRAY_BUFFER, (29791*5)*(sizeof(GLfloat)*6), 0, GL_DYNAMIC_DRAW);
    glBindBuffer(GL_ARRAY_BUFFER, 0);

    //Create Shader programs

    //List triangles
    consolePrint("Creating List Triangles Shader");
    Shader vertListTriangles(GL_VERTEX_SHADER);
    vertListTriangles.setSource(lst_tri_vert);
    vertListTriangles.compile();

    if(vertListTriangles.errorCheck() == GL_FALSE)
    {
        return false;
    }

    Shader geomListTriangles(GL_GEOMETRY_SHADER);
    geomListTriangles.setSource(lst_tri_geom);
    geomListTriangles.compile();
    geomListTriangles.errorCheck();

    if(geomListTriangles.errorCheck() == GL_FALSE)
    {
        return false;
    }

    mListTriangles.attach(vertListTriangles);
    mListTriangles.attach(geomListTriangles);



    errorCheck(__LINE__, __FILE__);


    //Gen vertices
    consolePrint("Creating Gen Vertices Shader");
    Shader vertGenVertices(GL_VERTEX_SHADER);
    vertGenVertices.setSource(gen_vert_vert);
    vertGenVertices.compile();

    if(vertGenVertices.errorCheck() == GL_FALSE)
    {
        return false;
    }

    Shader geomGenVertices(GL_GEOMETRY_SHADER);
    geomGenVertices.setSource(gen_vert_geom);
    geomGenVertices.compile();

    if(geomGenVertices.errorCheck() == GL_FALSE)
    {
        return false;
    }

    mGenVertices.attach(vertGenVertices);
    mGenVertices.attach(geomGenVertices);

const GLchar* varyings1[1];
    varyings1[0] = "gTriangle";
    glTransformFeedbackVaryings(mListTriangles.getID(), 1, varyings1, GL_INTERLEAVED_ATTRIBS);

    mListTriangles.link();
    if(mListTriangles.checkLink() == GL_FALSE)
    {
        return false;
    }


const GLchar* varyings2[2];
    varyings2[0] = "position";
    varyings2[1] = "normal";
    glTransformFeedbackVaryings(mGenVertices.getID(), 2, varyings2, GL_INTERLEAVED_ATTRIBS);

    mGenVertices.link();
    if(mGenVertices.checkLink() == GL_FALSE)
    {
        return false;
    }


    //Remeber we are using GPU, assuming nothing went wrong
    mUseCPU = false;
    return true;
}

void VoxelConverter::initCPU()
{
    mUseCPU = true;
}

void VoxelConverter::convert(MatterNode* matter)
{
    if(mUseCPU)
    {
        convertCPU(matter);
    }
    else
    {
        convertGPU(matter);
    }
}

//takes an two 4 bit corner indices and outputs one 4 bit edge index.
GLuint VoxelConverter::getEdgeNumber(GLuint cornerIndices)
{
	GLuint result = 12;

	/*00000011*/
	if(cornerIndices == 0x01 || cornerIndices == 0x10) result = 0;
	/*00000101*/
	else if(cornerIndices == 0x02 || cornerIndices == 0x20) result = 1;
	/*00001100*/
	else if(cornerIndices == 0x23 || cornerIndices == 0x32) result = 2;
	/*00001010*/
	else if(cornerIndices == 0x13 || cornerIndices == 0x31) result = 3;
	/*00110000*/
	else if(cornerIndices == 0x45 || cornerIndices == 0x54) result = 4;
	/*01010000*/
	else if(cornerIndices == 0x46 || cornerIndices == 0x64) result = 5;
	/*11000000*/
	else if(cornerIndices == 0x67 || cornerIndices == 0x76) result = 6;
	/*10100000*/
	else if(cornerIndices == 0x57 || cornerIndices == 0x75) result = 7;
	/*00010001*/
	else if(cornerIndices == 0x04 || cornerIndices == 0x40) result = 8;
	/*01000100*/
	else if(cornerIndices == 0x26 || cornerIndices == 0x62) result = 9;
	/*10001000*/
	else if(cornerIndices == 0x37 || cornerIndices == 0x73) result = 10;
	/*00100010*/
	else if(cornerIndices == 0x15 || cornerIndices == 0x51) result = 11;

	return result;
}

void VoxelConverter::convertCPU(MatterNode* matterNode)
{
    mApp->debugPrint(App::DEBUG_MARCHING_CUBES, "Attempting to convert voxel field with CPU.");

    matterNode->getMatter()->beginProcessing();

    mXOffset = -matterNode->getMatter()->getVoxelField()->getCenterOfMass().x*mVoxelSpacing;
    mYOffset = -matterNode->getMatter()->getVoxelField()->getCenterOfMass().y*mVoxelSpacing;
    mZOffset = -matterNode->getMatter()->getVoxelField()->getCenterOfMass().z*mVoxelSpacing;

    double start = glfwGetTime();
    VoxelDecomposer decomp;
    decomp.decompose(matterNode->getMatter()->getVoxelField());
    matterNode->getMatter()->setupHulls();
    double decomposed = glfwGetTime();
    mApp->debugPrint(App::DEBUG_VOX_DECOMP, "Time to decomp: ", (decomposed - start));
    listTrianglesCPU(matterNode->getMatter());
    genVerticesCPU(matterNode->getMatter());
    double generated = glfwGetTime();
    mApp->debugPrint(App::DEBUG_VOX_DECOMP, "Time to gen: ", (generated - decomposed));
    matterNode->getMatter()->endProcessing(matterNode);

}

void VoxelConverter::listTrianglesCPU(Matter* matter)
{
    VoxelField* vox = matter->getVoxelField();

    for(unsigned int z = 0; z < 31; z++)
    {
        for(unsigned int y = 0; y < 31; y++)
        {
            for(unsigned int x = 0; x < 31; x++)
            {
                //Normal addition components.
                Vector3f normal0(1.0f, 1.0f, 1.0f);
                Vector3f normal1(-1.0f, 1.0f, 1.0f);
                Vector3f normal2(1.0f, -1.0f, 1.0f);
                Vector3f normal3(-1.0f, -1.0f, 1.0f);
                Vector3f normal4(1.0f, 1.0f, -1.0f);
                Vector3f normal5(-1.0f, 1.0f, -1.0f);
                Vector3f normal6(1.0f, -1.0f, -1.0f);
                Vector3f normal7(-1.0f, -1.0f, -1.0f);

                //Corner coordinates, check the diagram to find out what goes where.
                Vector3i corner0;

                corner0.x = x;
                corner0.y = y;
                corner0.z = z;

                Vector3i corner1;
                Vector3i corner2;
                Vector3i corner3;
                Vector3i corner4;
                Vector3i corner5;
                Vector3i corner6;
                Vector3i corner7;

                corner1.x = corner0.x+1;
                corner1.y = corner0.y;
                corner1.z = corner0.z;

                corner2.x = corner0.x;
                corner2.y = corner0.y+1;
                corner2.z = corner0.z;

                corner3.x = corner0.x+1;
                corner3.y = corner0.y+1;
                corner3.z = corner0.z;

                corner4.x = corner0.x;
                corner4.y = corner0.y;
                corner4.z = corner0.z+1;

                corner5.x = corner4.x+1;
                corner5.y = corner4.y;
                corner5.z = corner4.z;

                corner6.x = corner4.x;
                corner6.y = corner4.y+1;
                corner6.z = corner4.z;

                corner7.x = corner4.x+1;
                corner7.y = corner4.y+1;
                corner7.z = corner4.z;



                GLuint corners = 0;

                GLubyte sample0 = vox->getValue(corner0);
                GLubyte sample1 = vox->getValue(corner1);
                GLubyte sample2 = vox->getValue(corner2);
                GLubyte sample3 = vox->getValue(corner3);
                GLubyte sample4 = vox->getValue(corner4);
                GLubyte sample5 = vox->getValue(corner5);
                GLubyte sample6 = vox->getValue(corner6);
                GLubyte sample7 = vox->getValue(corner7);

                int fullVoxels = 0;
                Vector3f cubeNormal(0.0f, 0.0f, 0.0f);

                if(sample0 != 0)
                {
                    fullVoxels++;
                    cubeNormal.add(normal0);
                    corners = corners | 1;
                    addVoxelVertex(matter, corner0);
                }
                if(sample1 != 0)
                {
                    fullVoxels++;
                    cubeNormal.add(normal1);
                    corners = corners | 2;
                    if(x == 30)
                    {
                        addVoxelVertex(matter, corner1);
                    }
                }
                if(sample2 != 0)
                {
                    fullVoxels++;
                    cubeNormal.add(normal2);
                    corners = corners | 4;
                    if(y == 30)
                    {
                        addVoxelVertex(matter, corner2);
                    }
                }
                if(sample3 != 0)
                {
                    fullVoxels++;
                    cubeNormal.add(normal3);
                    corners = corners | 8;
                    if(y == 30)
                    {
                        addVoxelVertex(matter, corner3);
                    }
                }
                if(sample4 != 0)
                {
                    fullVoxels++;
                    cubeNormal.add(normal4);
                    corners = corners | 16;
                    if(z == 30)
                    {
                        addVoxelVertex(matter, corner4);
                    }
                }
                if(sample5 != 0)
                {
                    fullVoxels++;
                    cubeNormal.add(normal5);
                    corners = corners | 32;
                    if(z == 30)
                    {
                        addVoxelVertex(matter, corner5);
                    }
                }
                if(sample6 != 0)
                {
                    fullVoxels++;
                    cubeNormal.add(normal6);
                    corners = corners | 64;
                    if(z == 30)
                    {
                        addVoxelVertex(matter, corner6);
                    }
                }
                if(sample7 != 0)
                {
                    fullVoxels++;
                    cubeNormal.add(normal7);
                    corners = corners | 128;
                    if(z == 30)
                    {
                        addVoxelVertex(matter, corner7);
                    }
                }

                bool isPartOfHull = !(fullVoxels == 0) && !(fullVoxels == 8);

                if(isPartOfHull)
                {
                    cubeNormal.normalize();
                    if(sample0 != 0)
                    {
                        addHullVertex(matter, corner0, cubeNormal);
                    }
                    if(sample1 != 0)
                    {
                        addHullVertex(matter, corner1, cubeNormal);
                    }
                    if(sample2 != 0)
                    {
                        addHullVertex(matter, corner2, cubeNormal);
                    }
                    if(sample3 != 0)
                    {
                        addHullVertex(matter, corner3, cubeNormal);
                    }
                    if(sample4 != 0)
                    {
                        addHullVertex(matter, corner4, cubeNormal);
                    }
                    if(sample5 != 0)
                    {
                        addHullVertex(matter, corner5, cubeNormal);
                    }
                    if(sample6 != 0)
                    {
                        addHullVertex(matter, corner6, cubeNormal);
                    }
                    if(sample7 != 0)
                    {
                        addHullVertex(matter, corner7, cubeNormal);
                    }
                }

                GLuint cellClass = regularCellClass[corners];
                RegularCellData data = regularCellData[cellClass];
                GLuint vertCount = data.getVertexCount();
                GLuint triangleCount = data.getTriangleCount();

                for(unsigned int i = 0; i < triangleCount; i++)
                {
                    GLuint index1 = data.mVertexIndex[(i*3)];
                    GLuint index2 = data.mVertexIndex[(i*3)+1];
                    GLuint index3 = data.mVertexIndex[(i*3)+2];

                    //These edges are written as a concat of their corners.
                    GLuint edge1 = regularVertexData[12*corners+index1];
                    GLuint edge2 = regularVertexData[12*corners+index2];
                    GLuint edge3 = regularVertexData[12*corners+index3];

                    //Convert to Edge number, rather than using corners to identify each edge.
                    edge1 = getEdgeNumber(edge1 & 0xFF);
                    edge2 = getEdgeNumber(edge2 & 0xFF);
                    edge3 = getEdgeNumber(edge3 & 0xFF);

                    //Ensure 4 bits only then shift to posistion.
                    edge1 = (edge1 & 0xF) << 8;
                    edge2 = (edge2 & 0xF) << 4;
                    edge3 = edge3 & 0xF;

                    GLuint x_y_z = 0;
                    x_y_z = x_y_z | (x << 25);
                    x_y_z = x_y_z | (y << 20);
                    x_y_z = x_y_z | (z << 15);

                    GLuint output = x_y_z | edge1 | edge2 | edge3;
                    mTriangleArray.push_back(output);
                }
            }
        }
    }
    matter->hullsDone();
}

void VoxelConverter::genVerticesCPU(Matter* matter)
{
    VoxelField* vox = matter->getVoxelField();
    VertexShell* vert = matter->getVertexShell();

    GLfloat halfSpace = mVoxelSpacing*0.5f;
	GLfloat totalSpace = mVoxelSpacing*32.0f;
	GLfloat spaceRatio = 1.0f/32.0f;

    for(unsigned int i = 0; i < mTriangleArray.size(); i++)
    {
        GLuint triangle = mTriangleArray[i];

        GLuint voxX = (triangle >> 25) & 31;
        GLuint voxY = (triangle >> 20) & 31;
        GLuint voxZ = (triangle >> 15) & 31;

        GLuint edge[3];
        edge[0] = (triangle >> 8) & 0xF;
        edge[1] = (triangle >> 4) & 0xF;
        edge[2] = triangle & 0xF;

        /*Place a vertex on each edge.*/
        Vector3f coord[3];
        coord[0] = Vector3f((float(voxX)*mVoxelSpacing)+mXOffset,(float(voxY)*mVoxelSpacing)+mYOffset,(float(voxZ)*mVoxelSpacing)+mZOffset);
        coord[1] = Vector3f((float(voxX)*mVoxelSpacing)+mXOffset,(float(voxY)*mVoxelSpacing)+mYOffset,(float(voxZ)*mVoxelSpacing)+mZOffset);
        coord[2] = Vector3f((float(voxX)*mVoxelSpacing)+mXOffset,(float(voxY)*mVoxelSpacing)+mYOffset,(float(voxZ)*mVoxelSpacing)+mZOffset);

        Vector3f normal[3];

        for(int i = 0; i < 3; i++)
        {
            if(edge[i] == 0)
            {
                coord[i].x = coord[i].x + halfSpace;
            }
            else if(edge [i] == 1)
            {
                coord[i].y = coord[i].y + halfSpace;
            }
            else if(edge [i] == 2)
            {
                coord[i].x = coord[i].x + halfSpace;
                coord[i].y = coord[i].y + mVoxelSpacing;
            }
            else if(edge [i] == 3)
            {
                coord[i].x = coord[i].x + mVoxelSpacing;
                coord[i].y = coord[i].y + halfSpace;
            }
            else if(edge [i] == 4)
            {
                coord[i].x = coord[i].x + halfSpace;
                coord[i].z = coord[i].z + mVoxelSpacing;
            }
            else if(edge [i] == 5)
            {
                coord[i].y = coord[i].y + halfSpace;
                coord[i].z = coord[i].z + mVoxelSpacing;
            }
            else if(edge [i] == 6)
            {
                coord[i].x = coord[i].x + halfSpace;
                coord[i].y = coord[i].y + mVoxelSpacing;
                coord[i].z = coord[i].z + mVoxelSpacing;
            }
            else if(edge [i] == 7)
            {
                coord[i].x = coord[i].x + mVoxelSpacing;
                coord[i].y = coord[i].y + halfSpace;
                coord[i].z = coord[i].z + mVoxelSpacing;
            }
            else if(edge [i] == 8)
            {
                coord[i].z = coord[i].z + halfSpace;
            }
            else if(edge [i] == 9)
            {
                coord[i].y = coord[i].y + mVoxelSpacing;
                coord[i].z = coord[i].z + halfSpace;
            }
            else if(edge [i] == 10)
            {
                coord[i].x = coord[i].x + mVoxelSpacing;
                coord[i].y = coord[i].y + mVoxelSpacing;
                coord[i].z = coord[i].z + halfSpace;
            }
            else if(edge [i] == 11)
            {
                coord[i].x = coord[i].x + mVoxelSpacing;
                coord[i].z = coord[i].z + halfSpace;
            }

            if(edge[i] != 12)
            {
                /*Create a normal from the rate of change in x, y and z*/

                float halfVoxel = halfSpace/totalSpace;

                float xSample = (coord[i].x/totalSpace);
                float ySample = (coord[i].y/totalSpace);
                float zSample = (coord[i].z/totalSpace);

                normal[i].x = vox->sample(xSample+halfVoxel, ySample, zSample) - vox->sample(xSample-halfVoxel, ySample, zSample);

                normal[i].y = vox->sample(xSample, ySample+halfVoxel, zSample) - vox->sample(xSample, ySample-halfVoxel, zSample);

                normal[i].z = vox->sample(xSample, ySample, zSample+halfVoxel) - vox->sample(xSample, ySample, zSample-halfVoxel);

                normal[i].normalize();
            }
        }

        vert->addVertex(coord[0], normal[0]);
        vert->addVertex(coord[1], normal[1]);
        vert->addVertex(coord[2], normal[2]);
    }

    mTriangleArray.clear();
}

void VoxelConverter::convertGPU(MatterNode* matterNode)
{
    consolePrint("Attempting to convert voxel field with GPU.");
    consolePrint("Printing 3D volume texture.");

    errorCheck(__LINE__, __FILE__);

    //Create a new buffer for the GPU to write directly to.
    Buffer* vertexBuffer = new Buffer();
    vertexBuffer->init();    errorCheck(__LINE__, __FILE__);

    //Get data from voxel field
    matterNode->getMatter()->getVoxelField()->printAs3DTexture(mVolumeTexture);    errorCheck(__LINE__, __FILE__);

    listTrianglesGPU();    errorCheck(__LINE__, __FILE__);

    genVerticesGPU(vertexBuffer);    errorCheck(__LINE__, __FILE__);

    matterNode->getMatter()->getVertexShell()->setBuffer(vertexBuffer);

/*
    glBindTexture(GL_TEXTURE_3D, mVolumeTexture);
    GLfloat* image = new GLfloat[32768*3];
    glGetTexImage(GL_TEXTURE_3D, 0, GL_RGB, GL_FLOAT, image);
*/

    errorCheck(__LINE__, __FILE__);
    glBindBuffer(GL_ARRAY_BUFFER, mTriangleBuffer);
    GLuint* testTris = (GLuint*)glMapBuffer(GL_ARRAY_BUFFER, GL_READ_ONLY);
    errorCheck(__LINE__, __FILE__);
    glUnmapBuffer(GL_ARRAY_BUFFER);

    glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer->getName());
    GLfloat* testVert = (GLfloat*)glMapBuffer(GL_ARRAY_BUFFER, GL_READ_ONLY);
    errorCheck(__LINE__, __FILE__);
    glUnmapBuffer(GL_ARRAY_BUFFER);

    //delete image;

}

void VoxelConverter::listTrianglesGPU()
{

    //Use list triangles shader
    mListTriangles.use();

    //Disable Rastering
    glEnable(GL_RASTERIZER_DISCARD);

    //Input buffer: Initial vertices
    glBindBuffer(GL_ARRAY_BUFFER, mInitialDataBuffer); errorCheck(__LINE__, __FILE__);
    GLint attribLocation = glGetAttribLocation(mListTriangles.getID(), "x_y_z");
    glEnableVertexAttribArray(attribLocation);
    glVertexAttribIPointer(attribLocation, 1, GL_UNSIGNED_INT, 0, 0);

    //Output buffer: Triangles
    glBindBufferBase(GL_TRANSFORM_FEEDBACK_BUFFER, 0, mTriangleBuffer);

    //Texture setup
    GLint sampler = glGetUniformLocation(mListTriangles.getID(), "densityVol");
    glUniform1i(sampler, 0);
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_3D, mVolumeTexture);

    //Transform Feedback
    glBeginTransformFeedback(GL_POINTS);

        glDrawArrays(GL_POINTS, 0, 29790);

    glEndTransformFeedback();

    //Re-enable Rastering
    glDisable(GL_RASTERIZER_DISCARD);
    glDisableVertexAttribArray(0);
    glBindBuffer(GL_ARRAY_BUFFER, 0);
}

void VoxelConverter::genVerticesGPU(Buffer* vertexBuffer)
{
    //Prepare vertex buffer
    glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer->getName());
    glBufferData(GL_ARRAY_BUFFER, (29791*5)*(sizeof(GLfloat)*6), 0, GL_DYNAMIC_DRAW);
    glBindBuffer(GL_ARRAY_BUFFER, 0);

    //Use gen vertices shader
    mGenVertices.use();     errorCheck(__LINE__, __FILE__);

    //Disable Rastering
    glEnable(GL_RASTERIZER_DISCARD);     errorCheck(__LINE__, __FILE__);

    //Input buffer: Triangle buffer
    glBindBuffer(GL_ARRAY_BUFFER, mTriangleBuffer);     errorCheck(__LINE__, __FILE__);
    GLint attribLocation = glGetAttribLocation(mGenVertices.getID(), "triangle");
    glEnableVertexAttribArray(attribLocation);
    glVertexAttribIPointer(attribLocation, 1, GL_UNSIGNED_INT, 0, 0);     errorCheck(__LINE__, __FILE__);

    //Output buffer: Vertices
    glBindBufferBase(GL_TRANSFORM_FEEDBACK_BUFFER, 0, vertexBuffer->getName());     errorCheck(__LINE__, __FILE__);

    //Texture setup
    GLint sampler = glGetUniformLocation(mGenVertices.getID(), "densityVol");     errorCheck(__LINE__, __FILE__);
    glUniform1i(sampler, 0);     errorCheck(__LINE__, __FILE__);
    glActiveTexture(GL_TEXTURE0);     errorCheck(__LINE__, __FILE__);
    glBindTexture(GL_TEXTURE_3D, mVolumeTexture);     errorCheck(__LINE__, __FILE__);

    //Set spaceing variable.
    GLint space = glGetUniformLocation(mGenVertices.getID(), "voxelSpace");     errorCheck(__LINE__, __FILE__);
    glUniform1f(space, mVoxelSpacing);     errorCheck(__LINE__, __FILE__);

    //Transform Feedback
    glBeginTransformFeedback(GL_POINTS);     errorCheck(__LINE__, __FILE__);

        glDrawArrays(GL_POINTS, 0, 29791*5);     errorCheck(__LINE__, __FILE__);

    glEndTransformFeedback();     errorCheck(__LINE__, __FILE__);

    //Re-enable Rastering
    glDisable(GL_RASTERIZER_DISCARD);     errorCheck(__LINE__, __FILE__);
    glDisableVertexAttribArray(0);     errorCheck(__LINE__, __FILE__);
    glBindBuffer(GL_ARRAY_BUFFER, 0);     errorCheck(__LINE__, __FILE__);
}

//Deprecated hacky function
void VoxelConverter::drawLast()
{
    //glUseProgramObjectARB(0);
    glDisable(GL_TEXTURE_3D);

    //Use standard vertex arrays
    glEnableClientState(GL_VERTEX_ARRAY);
    glEnableClientState(GL_NORMAL_ARRAY);



    if(mUseCPU)
    {
        //Draw from vectors.
        glBindBuffer(GL_ARRAY_BUFFER, 0);

        glVertexPointer(3, GL_FLOAT, 24, mVertexArray.data());
        glNormalPointer(GL_FLOAT, 24, &(mVertexArray.data()[3]));

        glColor3f(0.0f, 1.0f, 0.0f);

        glDrawArrays(GL_TRIANGLES, 0, mVertexArray.size()/6);

    }
    else
    {
        //Draw from buffer.
        //Input buffer: vertices
        glBindBuffer(GL_ARRAY_BUFFER, mVertexBuffer);

        //Setup arrays
        glVertexPointer(3, GL_FLOAT, 24, 0);

        glNormalPointer(GL_FLOAT, 24, (const GLvoid*)12);
        //Just draw everything as flat green for now.
        glColor3f(0.0f, 1.0f, 0.0f);

        glDrawArrays(GL_TRIANGLES, 0, 29791*5*3);

        glBindBuffer(GL_ARRAY_BUFFER, 0);
    }


errorCheck(__LINE__, __FILE__);
    glDisableClientState(GL_VERTEX_ARRAY);
    glDisableClientState(GL_NORMAL_ARRAY);

    errorCheck(__LINE__, __FILE__);

}

void VoxelConverter::addVoxelVertex(Matter* matter, Vector3i voxelCoord)
{
    int hullID = matter->getVoxelField()->hullAt(voxelCoord);
    Vector3f vertex((float(voxelCoord.x)*mVoxelSpacing)+mXOffset, (float(voxelCoord.y)*mVoxelSpacing)+mYOffset, (float(voxelCoord.z)*mVoxelSpacing)+mZOffset);
    matter->addVoxelVertex(hullID, vertex);
}

void VoxelConverter::addHullVertex(Matter* matter, Vector3i voxelCoord, Vector3f normal)
{
    int hullID = matter->getVoxelField()->hullAt(voxelCoord);

    Vector3f vertex((float(voxelCoord.x)*mVoxelSpacing)+mXOffset+((mVoxelSpacing/2)*normal.x),
                    (float(voxelCoord.y)*mVoxelSpacing)+mYOffset+((mVoxelSpacing/2)*normal.y),
                    (float(voxelCoord.z)*mVoxelSpacing)+mZOffset+((mVoxelSpacing/2)*normal.z));

    matter->addHullVertex(hullID, vertex);
}
